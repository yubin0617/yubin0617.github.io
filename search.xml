<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《玉楼春》</title>
      <link href="/2019/04/06/yu-lou-chun/"/>
      <url>/2019/04/06/yu-lou-chun/</url>
      
        <content type="html"><![CDATA[<p>#<center>玉楼春·春景</center>#</p><p><center frontsize="14">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>北宋 &nbsp;宋祁</strong></center></p><p><center><h2><em>东城渐觉风光好，縠皱波纹迎客棹。</em></h2></center></p><p><center><h2><em>绿杨烟外晓寒轻，红杏枝头春意闹。</em></h2></center></p><p><center><h2><em>浮生长恨欢娱少。肯爱千金轻一笑。</em></h2></center></p><p><center><h2><em>为君持酒劝斜阳，且向花间留晚照。</em></h2><center><br><img src="https://i.imgur.com/Abn9q2y.jpg" alt=""></center></center></p>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2019/04/05/er-cha-shu/"/>
      <url>/2019/04/05/er-cha-shu/</url>
      
        <content type="html"><![CDATA[<pre><code> 建立一棵二叉树，试编程实现二叉树的如下基本操作</code></pre><ol><li>按先序序列构造一棵二叉链表表示的二叉树T；</li><li>对这棵二叉树进行遍历：先序、中序、后序以及层次遍历，分别输出结点的遍历序列；</li><li>求二叉树的深度/结点数目/叶结点数目；(选做)</li><li><p>将二叉树每个结点的左右子树交换位置。（选做）<br>&lt;–!more–&gt;<br><code>`</code><br>#include<iostream><br>using namespace std;<br>//定义节点<br>typedef struct node                             //定义二叉树存储结构<br>{<br> struct node <em>lchild;<br> struct node </em>rchild;<br> char data;<br>}BiTreeNode, <em>BiTree;<br>typedef struct                                 //定义队列<br>{<br> BiTree </em>base;<br> int front;<br> int rear;<br>}Squeue;<br>int chushihua(Squeue &amp;Q)                       //出栈函数<br>{<br> Q.base = new BiTree[100];                  //分配栈的空间<br> if (!Q.base)                               //判断是否分配成功</iostream></p><pre><code> return 0;                             </code></pre><p> Q.front = Q.rear = 0;                      //队列初始化为空<br> return 0;<br>}<br>int rudui(Squeue &amp;Q,BiTree T)                  //出队函数<br>{<br> if ((Q.rear + 1) % 100 == Q.front)         //如果队满，就退出</p><pre><code> return -1;</code></pre><p> Q.base[Q.rear] = T;                        //入队<br> Q.rear = (Q.rear + 1) % 100;               //队列的顶加一<br> return 0;<br>}<br>int chudui(Squeue &amp;Q, BiTree &amp;S)              //出队<br>{<br> if (Q.front == Q.rear)                     //判断队列是否为空</p><pre><code> return -1;</code></pre><p> S= Q.base[Q.front];                        //s出队<br> Q.front = (Q.front + 1) % 100;             //队尾指针加一<br> return 0;<br>}</p><pre><code>                                        //按照前序顺序建立二叉树</code></pre><p>void createBiTree(BiTree &amp;T)                   //&amp;的意思是传进来节点指针的引用，括号内等价于 BiTreeNode* &amp;T,目的是让传递进来的指针发生改变<br>{<br> char c;<br> cin &gt;&gt; c;<br> if (‘#’ == c)                             //当遇到#时，令树的根节点为NULL，从而结束该分支的递归</p><pre><code> T = NULL;</code></pre><p> else<br> {</p><pre><code> T = new BiTreeNode;                   //创建新节点树 T-&gt;data = c;                          //新节点为c createBiTree(T-&gt;lchild);              //创建左子树 createBiTree(T-&gt;rchild);              //创建右子树</code></pre><p> }<br>}</p><pre><code>                                       //前序遍历二叉树并打印</code></pre><p>void preTraverse(BiTree T)<br>{<br> if (T)<br> {</p><pre><code> cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;;              //输出中间节点 preTraverse(T-&gt;lchild);              //遍历左子树 preTraverse(T-&gt;rchild);              //遍历右子树</code></pre><p> }<br>}</p><pre><code>                                      //中序遍历二叉树并打印</code></pre><p>void midTraverse(BiTree T)<br>{<br> if (T)<br> {</p><pre><code> midTraverse(T-&gt;lchild);              //遍历左子树 cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;;              //遍历输出 midTraverse(T-&gt;rchild);              //遍历右子树</code></pre><p> }<br>}</p><pre><code>                                     //后续遍历二叉树并打印</code></pre><p>void postTraverse(BiTree T)<br>{<br> if (T)<br> {</p><pre><code> postTraverse(T-&gt;lchild);           //遍历左子树              postTraverse(T-&gt;rchild);           //遍历右子树 cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;;            //输出节点</code></pre><p> }<br>}</p><pre><code>                                    //层序遍历二叉树并打印</code></pre><p>int cengxu(BiTree T)<br>{<br> Squeue Q;<br> chushihua(Q);                          //初始化队列<br> BiTree root;<br> rudui(Q, T);                           //树的根节点入队<br> while (!(Q.front == Q.rear))           //当队列不为空时<br> {</p><pre><code> chudui(Q, root);                   //根节点出队 cout &lt;&lt; root-&gt;data&lt;&lt;&quot; &quot;; if (root-&gt;lchild)                  //如果根节点的左孩子存在，则入队     rudui(Q, root-&gt;lchild); if (root-&gt;rchild)                  //如果根节点的右孩子存在，则入队     rudui(Q, root-&gt;rchild);</code></pre><p> }<br> cout &lt;&lt; endl;<br> return 0;<br>}<br>int deep(BiTree T)                        //求二叉树深度<br>{<br> int m=0 , n=0;<br> if (T ==NULL)</p><pre><code> return 0;</code></pre><p> else<br> {</p><pre><code>  m=deep(T-&gt;lchild);               //递归遍历左孩子深度  n=deep(T-&gt;rchild);               //递归遍历右孩子深度 if (m &gt; n)     return (m + 1); else     return(n + 1);                //比较后输出大的作为深度</code></pre><p> }<br>}<br>int countye(BiTree T)                    //统计叶子节点个数<br>{<br> if (T == NULL)                       //如果树为空，退出</p><pre><code> return 0;</code></pre><p> else if (T-&gt;lchild == NULL&amp;&amp;T-&gt;rchild == NULL)</p><pre><code> return 1;                        //如果左右孩子都有，返回1</code></pre><p> else</p><pre><code> return countye(T-&gt;lchild) + countye(T-&gt;rchild);</code></pre><p>}                                       //返回左右子树相加的叶子节点<br>void swap(BiTree T)                    //交换函数<br>{<br> BiTree S;<br> S = T-&gt;lchild;<br> T-&gt;lchild = T-&gt;rchild;<br> T-&gt;rchild = S;<br>}<br>void jiaohuan(BiTree T)                  //交换左右孩子<br>{<br> if (T == NULL)</p><pre><code> return ;</code></pre><p> else<br> {</p><pre><code> swap(T); jiaohuan(T-&gt;lchild);           //中序遍历交换 jiaohuan(T-&gt;rchild);</code></pre><p> }<br>}<br>int main()<br>{<br> BiTree T;                          //声明一个指向二叉树根节点的指针<br> createBiTree(T);<br> cout &lt;&lt; “二叉树创建完成！” &lt;&lt; endl;<br> cout &lt;&lt; “前序遍历二叉树：” &lt;&lt; endl;<br> preTraverse(T);<br> cout &lt;&lt; endl;<br> cout &lt;&lt; “中序遍历二叉树：” &lt;&lt; endl;<br> midTraverse(T);<br> cout &lt;&lt; endl;<br> cout &lt;&lt; “后序遍历二叉树：” &lt;&lt; endl;<br> postTraverse(T);<br> cout &lt;&lt; endl;<br> cout &lt;&lt; “层序遍历二叉树” &lt;&lt; endl;<br> cengxu(T);<br> cout &lt;&lt; “二叉树的深度为：”;<br> cout &lt;&lt; deep(T)&lt;&lt;endl;<br> cout &lt;&lt; “叶子节点的个数为：”;<br> cout &lt;&lt; countye(T)&lt;&lt;endl;<br> jiaohuan(T);<br> cout &lt;&lt; “前序遍历交换后的二叉树：” &lt;&lt; endl;<br> preTraverse(T);<br> return 0;<br>}</p></li></ol><p><code>`</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bxh</title>
      <link href="/2018/11/20/bxh/"/>
      <url>/2018/11/20/bxh/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>你好!hexo</title>
      <link href="/2018/09/20/ni-hao-hexo/"/>
      <url>/2018/09/20/ni-hao-hexo/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/09/19/hello-world/"/>
      <url>/2018/09/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
